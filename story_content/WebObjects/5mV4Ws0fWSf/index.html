<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hyperbolic Cylinder</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="./lib/katex.min.css">
<style>
  html,body{margin:0;height:100%;background:#0a0e14;color:#eaeef2;font-family:system-ui;overflow:hidden}
  #hud{position:fixed;top:10px;left:10px;z-index:10;background:#1118;border:1px solid #334;padding:10px 12px;border-radius:8px}
  #hud button,#hud input{margin:3px 0}
  #hint{position:fixed;right:10px;bottom:10px;z-index:10;background:#1118;border:1px solid #334;border-radius:8px;padding:6px 8px;font-size:12px;color:#c8cede}
  .axis-label{font-family:"KaTeX_Main","Latin Modern Math","STIX Two Text",serif;font-size:18px;color:#e8ecff;text-shadow:0 0 4px rgba(20,30,60,.6);user-select:none;pointer-events:none}
  .eq-white{color:#ffffff;text-shadow:0 0 6px rgba(0,0,0,.35)}
  .eq-red{color:#ff5252;text-shadow:0 0 6px rgba(60,10,10,.45)}
  #c{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<div id="hud">
  <div style="font-weight:700;margin-bottom:6px">Hyperbolic Cylinder</div>
  <label>Duration (s): <input id="dur" type="number" value="8" min="3" max="60" style="width:64px"></label><br>
  <label> a (x-semi-axis): <input id="a" type="number" value="1.4" step="0.1" style="width:64px"></label><br>
  <label> b (y-semi-axis): <input id="b" type="number" value="1.0" step="0.1" style="width:64px"></label><br>
  <label> Y<sub>max</sub>: <input id="ymax" type="number" value="2.2" step="0.1" style="width:64px"></label><br>
  <!-- Mặc định 5.0, thấp hơn mũi tên trục z (AXLEN=6) -->
  <label> L (along z): <input id="len" type="number" value="5.0" step="0.1" style="width:64px"></label>
  <div style="margin-top:4px"><button id="play">Play/Pause</button> <button id="reset">Reset</button></div>
</div>

<div id="hint">Kéo để xoay • Lăn/pinch để zoom • Shift+Kéo để di chuyển</div>
<canvas id="c"></canvas>

<script src="./lib/three.min.js"></script>
<script src="./lib/OrbitControls.js"></script>
<script src="./lib/CSS2DRenderer.js"></script>
<script src="./lib/katex.min.js"></script>

<script>
// === Renderer & label renderer ===
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(innerWidth, innerHeight);

const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
Object.assign(labelRenderer.domElement.style, {position:'fixed', top:'0', left:'0', pointerEvents:'none', zIndex:'5'});
document.body.appendChild(labelRenderer.domElement);

// === Scene / Camera / Controls ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0e14);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(6,-6,4);
camera.up.set(0,0,1);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.zoomSpeed = 0.25;
controls.minDistance = 3.0;
controls.maxDistance = 40.0;
controls.update();

// Resize
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  labelRenderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.8));
const dir = new THREE.DirectionalLight(0xffffff, 0.7); dir.position.set(6,6,8); scene.add(dir);

// Axes + grid
const AXLEN = 6;
const matX = new THREE.LineBasicMaterial({color:0xff6b6b, transparent:true, opacity:0.7});
const matY = new THREE.LineBasicMaterial({color:0x7be77b, transparent:true, opacity:0.7});
const matZ = new THREE.LineBasicMaterial({color:0x6fa8ff, transparent:true, opacity:0.9});
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-AXLEN,0,0), new THREE.Vector3(AXLEN,0,0)]), matX));
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,-AXLEN,0), new THREE.Vector3(0,AXLEN,0)]), matY));
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-AXLEN), new THREE.Vector3(0,0,AXLEN)]), matZ));
const cone = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.25, 16), new THREE.MeshBasicMaterial({color:0x6fa8ff, transparent:true, opacity:0.9}));
cone.position.set(0,0,AXLEN); cone.rotation.x = Math.PI/2; scene.add(cone);

function makeGrid(size, divisions, c1, c2, opacity){
  const g = new THREE.GridHelper(size, divisions, c1, c2);
  if (Array.isArray(g.material)) g.material.forEach(m=>{ m.transparent = true; m.opacity = opacity; });
  else { g.material.transparent = true; g.material.opacity = opacity; }
  return g;
}
// Oxy (z=0)
const gridOxy = makeGrid(18, 18, 0xb6bbcc, 0x84878c, 0.22);
gridOxy.rotation.x = Math.PI/2;
scene.add(gridOxy);
// Oxz (y=0)
const gridOxz = makeGrid(18, 18, 0xb6bbcc, 0x84878c, 0.18);
scene.add(gridOxz);

// ------- KaTeX label helpers -------
function makeLatexLabel(tex, pos, className='axis-label'){
  const el = document.createElement('div'); el.className = className;
  window.katex.render(tex, el, {throwOnError:false});
  const obj = new THREE.CSS2DObject(el); obj.position.copy(pos); return obj;
}
const OFFSET = 0.25;
scene.add(
  makeLatexLabel("\\mathit{x}", new THREE.Vector3(AXLEN+OFFSET,0,0)),
  makeLatexLabel("\\mathit{y}", new THREE.Vector3(0,AXLEN+OFFSET,0)),
  makeLatexLabel("\\mathit{z}", new THREE.Vector3(0,0,AXLEN+OFFSET)),
);

// ------- Inputs -------
const durInput = document.getElementById('dur');
const aInput   = document.getElementById('a');
const bInput   = document.getElementById('b');
const ymaxInput= document.getElementById('ymax');
const lenInput = document.getElementById('len');

let A = Math.max(0.05, parseFloat(aInput.value));      // semi-axis along x (vertex at x=±A)
let B = Math.max(0.05, parseFloat(bInput.value));      // semi-axis along y
let YMAX = Math.max(0.5, parseFloat(ymaxInput.value)); // draw |y|<=YMAX
let L = Math.max(0.2, parseFloat(lenInput.value));     // translation length along z
let durationSec = parseFloat(durInput.value);

// Clamp L < arrow tip
function maxAllowedLen(){ return AXLEN - 0.3; }
function clampLen(v){ return Math.min(Math.max(0.2, v), maxAllowedLen()); }
L = clampLen(L); lenInput.value = L.toFixed(1);

// Helpers for hyperbola: x^2/a^2 - y^2/b^2 = 1 => x = ±a*sqrt(1 + (y^2/b^2))
function xAbsFromY(y){ return A*Math.sqrt(1 + (y*y)/(B*B)); }

// ------- Hyperbola profile in z=0 (two branches; moves along z) -------
let profileGrp = null, follower=null, eqHyperLabel=null;
let hyperLabelVisible = true; // bật lại khi Play
const LABEL_SHIFT_X = 0.20;   // dịch về +Ox cho nhãn
const LABEL_SHIFT_Z = 0.12;   // dịch về -Oz cho nhãn

function buildHyperbolaProfile(pts=240){
  if (profileGrp && profileGrp.parent){ profileGrp.parent.remove(profileGrp); }
  profileGrp = new THREE.Group();

  // sample y in [-YMAX, YMAX]
  const ys = new Array(pts+1).fill(0).map((_,i)=>-YMAX + 2*YMAX*i/pts);

  // Right branch (x>0)
  const rPts = ys.map(y=>new THREE.Vector3(+xAbsFromY(y), y, 0));
  const gR = new THREE.BufferGeometry().setFromPoints(rPts);
  const mR = new THREE.LineBasicMaterial({color:0xff5252});
  const rightLine = new THREE.Line(gR, mR);
  profileGrp.add(rightLine);

  // Left branch (x<0)
  const lPts = ys.map(y=>new THREE.Vector3(-xAbsFromY(y), y, 0));
  const gL = new THREE.BufferGeometry().setFromPoints(lPts);
  const mL = new THREE.LineBasicMaterial({color:0xff5252});
  const leftLine = new THREE.Line(gL, mL);
  profileGrp.add(leftLine);

  // marker at right vertex (A,0,0)
  follower = new THREE.Mesh(
    new THREE.SphereGeometry(0.045, 16, 12),
    new THREE.MeshBasicMaterial({color:0xffffff})
  );
  follower.position.set(A,0,0);
  profileGrp.add(follower);

  // Equation label attached near right vertex, slightly +x and -z
  const a2 = `${A.toFixed(2)}^{2}`, b2 = `${B.toFixed(2)}^{2}`;
  eqHyperLabel = makeLatexLabel(
    `\\;\\dfrac{x^{2}}{${a2}}-\\dfrac{y^{2}}{${b2}}=1\\;\\;(z=0)`,
    new THREE.Vector3(A + LABEL_SHIFT_X, 0, -LABEL_SHIFT_Z),
    'axis-label eq-red'
  );
  eqHyperLabel.visible = hyperLabelVisible;
  profileGrp.add(eqHyperLabel);

  scene.add(profileGrp);
}
buildHyperbolaProfile();

// ------- Cylinder equation label (show after sweep completes) -------
let eqSurf = null;
function createOrUpdateSurfLabel(){
  if (eqSurf && eqSurf.parent) eqSurf.parent.remove(eqSurf);
  const a2 = `${A.toFixed(2)}^{2}`, b2 = `${B.toFixed(2)}^{2}`;
  const yTop = YMAX + 0.5;
  eqSurf = makeLatexLabel(
    `\\;\\dfrac{x^{2}}{${a2}}-\\dfrac{y^{2}}{${b2}}=1`,
    new THREE.Vector3(0, yTop, Math.min(L + 0.2, maxAllowedLen())),
    'axis-label eq-white'
  );
  eqSurf.visible = false;
  scene.add(eqSurf);
}
createOrUpdateSurfLabel();

// ------- Sweep surface (translation along +z) -------
// Build two sheets: x= +x(y) and x= -x(y), y in [-YMAX,YMAX], z in [0,lenNow]
let meshRight=null, meshLeft=null, playing=false, tPrev=0, lenNow=0;

function buildSurface(len){
  // dispose old
  [meshRight, meshLeft].forEach(m=>{ if(m){ m.geometry.dispose(); scene.remove(m); }});
  meshRight = meshLeft = null;

  const vSeg = 120; // along y
  const uSeg = 60;  // along z
  const row = vSeg+1;

  function buildSheet(sign){ // sign = +1 for right, -1 for left
    const positions = new Float32Array((vSeg+1)*(uSeg+1)*3);
    let p=0;
    for(let iu=0; iu<=uSeg; iu++){
      const z = (len)*iu/uSeg;
      for(let iv=0; iv<=vSeg; iv++){
        const y = -YMAX + 2*YMAX*iv/vSeg;
        const xAbs = xAbsFromY(y);
        const x = sign * xAbs;
        positions[p++]=x; positions[p++]=y; positions[p++]=z;
      }
    }
    const idx=[];
    for(let iu=0; iu<uSeg; iu++){
      for(let iv=0; iv<vSeg; iv++){
        const a=iu*row+iv, b=a+1, c=(iu+1)*row+iv, d=c+1;
        idx.push(a,c,b, b,c,d);
      }
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geo.setIndex(idx);
    geo.computeVertexNormals();
    return geo;
  }

  const mat = new THREE.MeshStandardMaterial({
    color:0xbfd7ff,          // yêu cầu
    roughness:0.35, metalness:0.0,
    side:THREE.DoubleSide, transparent:true, opacity:0.95
  });

  meshRight = new THREE.Mesh(buildSheet(+1), mat);
  meshLeft  = new THREE.Mesh(buildSheet(-1), mat);
  scene.add(meshRight); scene.add(meshLeft);

  // Move generating curves group to the front face at z = len
  if (profileGrp){ profileGrp.position.set(0,0,len); }
}

// initial (len=0)
buildSurface(0);

// Loop
function tick(ts){
  if(!tPrev) tPrev=ts;
  const dt=(ts-tPrev)/1000; tPrev=ts;

  if(playing){
    const inc = (L/durationSec)*dt;
    lenNow = Math.min(L, lenNow + inc);
    buildSurface(lenNow);
    if (lenNow>=L){
      playing=false;
      if (eqSurf) eqSurf.visible = true;
    }
  }

  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// UI
document.getElementById('play').onclick=()=>{
  if(lenNow < L){
    playing = !playing;
    // bật lại label hyperbola khi Play để nó di chuyển theo
    hyperLabelVisible = true;
    if (eqHyperLabel) eqHyperLabel.visible = true;
  }
};
document.getElementById('reset').onclick=()=>{
  A = Math.max(0.05, parseFloat(aInput.value));
  B = Math.max(0.05, parseFloat(bInput.value));
  YMAX = Math.max(0.5, parseFloat(ymaxInput.value));
  L = clampLen(parseFloat(lenInput.value)); lenInput.value = L.toFixed(1);
  durationSec = parseFloat(durInput.value);
  lenNow = 0; playing=false;

  // ẨN label hyperbola sau khi reset
  hyperLabelVisible = false;

  buildHyperbolaProfile(Math.max(240, 2*120));
  createOrUpdateSurfLabel();
  if (eqSurf) eqSurf.visible = false;

  buildSurface(0);
};
</script>
</body>
</html>
