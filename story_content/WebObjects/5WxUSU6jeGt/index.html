<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hyperboloid of Two Sheets — Interactive Lesson (offline)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="./lib/katex.min.css">
<style>
  html,body{margin:0;height:100%;background:#0a0e14;color:#eaeef2;font-family:system-ui;overflow:hidden}
  #ui{position:fixed;top:10px;left:10px;z-index:20;background:#1118;border:1px solid #334;padding:10px 12px;border-radius:10px}
  #ui .row{margin:4px 0}
  #ui button{margin:2px 0 0 0; padding:6px 10px; border-radius:8px; border:1px solid #445; background:#1a1f2a; color:#eaeef2; cursor:pointer}
  #ui button.active{background:#2c3344; color:#cfd8ff}
  #ui2{position:fixed; top:10px; left:280px; z-index:20; background:#1118; border:1px solid #334; padding:10px 12px; border-radius:10px}
  #ui2 button{margin:2px 0 0 0; padding:6px 10px; border-radius:8px; border:1px solid #445; background:#1a1f2a; color:#eaeef2; cursor:pointer}
  #ui2 button.active{background:#2c3344; color:#cfd8ff}
  #hint{position:fixed;right:10px;bottom:10px;z-index:20;background:#1118;border:1px solid #334;border-radius:8px;padding:6px 8px;font-size:12px;color:#c8cede}
  #note{position:fixed;right:10px;top:10px;z-index:20;background:#1118;border:1px solid #334;border-radius:8px;padding:8px 10px;min-width:260px;max-width:42vw}
  .katex-block{font-size:16px}
  .axis-label{font-family:"KaTeX_Main","Latin Modern Math","STIX Two Text",serif;font-size:18px;color:#e8ecff;text-shadow:0 0 5px rgba(20,30,60,.65);user-select:none;pointer-events:none}
  .eq-label{font-family:"KaTeX_Main","Latin Modern Math","STIX Two Text",serif;font-size:18px;color:#e8ecff;text-shadow:0 0 5px rgba(20,30,60,.65);pointer-events:none}
  #c{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
  <div id="ui">
    <div class="row" style="font-weight:700;margin-bottom:6px">Hyperboloid of two sheets</div>
    <div class="row">
      <button id="btnEquation">equation</button>
      <button id="btnTraces">traces</button>
      <button id="btnSections">sections</button>
    </div>
    <div class="row">
      <button id="btnIntercepts">intercepts</button>
      <button id="btnCentre">centre</button>
      <button id="btnSymmetry">symmetry</button>
    </div>
  </div>
  <div id="ui2">
    <div style="font-weight:700;margin-bottom:6px">Control</div>
    <button id="btnResetAll">reset</button>
    <button id="btnPause">pause</button>
  </div>

  <div id="hint">Kéo để xoay • Lăn/pinch để zoom • Shift+Kéo để pan</div>
  <div id="note"></div>
  <canvas id="c"></canvas>

  <!-- Libraries -->
  <script src="./lib/three.min.js"></script>
  <script src="./lib/OrbitControls.js"></script>
  <script src="./lib/CSS2DRenderer.js"></script>
  <script src="./lib/katex.min.js"></script>

  <script>
  // ---------- Scene / Camera / Renderers ----------
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);

  const labelRenderer = new THREE.CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  Object.assign(labelRenderer.domElement.style,{position:'fixed',top:'0',left:'0',pointerEvents:'none',zIndex:'10'});
  document.body.appendChild(labelRenderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0e14);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(7,-7,5);
  camera.up.set(0,0,1); // Z-up

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0,0,0);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.zoomSpeed = 0.25;
  controls.minDistance = 3.0;
  controls.maxDistance = 40.0;
  controls.update();

  addEventListener('resize', ()=>{
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  });

  // ---------- Lights ----------
  scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.70));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.45);
  dirLight.position.set(6,6,8); scene.add(dirLight);

  // ---------- Axes + grids ----------
  const AXLEN = 7;
  const matX = new THREE.LineBasicMaterial({color:0xff6b6b, transparent:true, opacity:0.75});
  const matY = new THREE.LineBasicMaterial({color:0x7be77b, transparent:true, opacity:0.75});
  const matZ = new THREE.LineBasicMaterial({color:0x6fa8ff, transparent:true, opacity:0.95});
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-AXLEN,0,0), new THREE.Vector3(AXLEN,0,0)]), matX));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,-AXLEN,0), new THREE.Vector3(0,AXLEN,0)]), matY));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-AXLEN), new THREE.Vector3(0,0,AXLEN)]), matZ));

  function addAxisArrow(dirVec, tipPos, color=0x6fa8ff){
    const cone = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.30, 20),
      new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.95}));
    const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirVec.clone().normalize());
    cone.quaternion.copy(q); cone.position.copy(tipPos); scene.add(cone); return cone;
  }
  addAxisArrow(new THREE.Vector3(1,0,0), new THREE.Vector3(AXLEN,0,0), 0xff6b6b);
  addAxisArrow(new THREE.Vector3(0,1,0), new THREE.Vector3(0,AXLEN,0), 0x7be77b);
  addAxisArrow(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,AXLEN), 0x6fa8ff);

  const gridOxy = new THREE.GridHelper(16, 16, 0xa7abc2, 0xb3b5c4);
  gridOxy.rotation.x = Math.PI/2; makeGridTransparent(gridOxy, 0.22); scene.add(gridOxy);
  const gridOxz = new THREE.GridHelper(16, 16, 0xa7abc2, 0xb3b5c4);
  makeGridTransparent(gridOxz, 0.22); gridOxz.visible=false; scene.add(gridOxz);
  const gridOyz = new THREE.GridHelper(16, 16, 0xa7abc2, 0xb3b5c4);
  gridOyz.rotation.z = Math.PI/2; makeGridTransparent(gridOyz, 0.22); gridOyz.visible=false; scene.add(gridOyz);
  function makeGridTransparent(grid, opacity){
    if (Array.isArray(grid.material)) grid.material.forEach(m=>{m.transparent=true; m.opacity=opacity;});
    else { grid.material.transparent=true; grid.material.opacity=opacity; }
  }

  // ---------- Hyperboloid (two sheets) params ----------
  let X0=0, Y0=0, Z0=0;     // centre
  let a=3.6, b=2.6, c=1.8;  // semi-axes
  const U_MAX = 1.30;       // kiểm soát độ mở + phạm vi mesh
  const SEG_U = 96, SEG_V = 160;

  // tiện lợi: biên theo u
  const Z_MAX = c*Math.cosh(U_MAX), R_MAX_X = a*Math.sinh(U_MAX), R_MAX_Y = b*Math.sinh(U_MAX);

  // ---------- Build hyperboloid (two sheets) ----------
  // z = ± c cosh u, x = a sinh u cos v, y = b sinh u sin v
  function buildTwoSheets(x0,y0,z0,a,b,c, uMax=U_MAX, uSeg=SEG_U, vSeg=SEG_V){
    const group = new THREE.Group();
    function buildSheet(sign=+1){
      const uS=Math.max(8,uSeg), vS=Math.max(16,vSeg);
      const pos = new Float32Array((uS+1)*(vS+1)*3); let p=0;
      for(let iu=0; iu<=uS; iu++){
        const u = uMax * iu/uS;
        const su = Math.sinh(u), cu = Math.cosh(u);
        for(let iv=0; iv<=vS; iv++){
          const th = 2*Math.PI*iv/vS;
          const cs = Math.cos(th), sn = Math.sin(th);
          pos[p++] = x0 + a*su*cs;
          pos[p++] = y0 + b*su*sn;
          pos[p++] = z0 + sign * c*cu;
        }
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const idx=[];
      for(let iu=0; iu<uS; iu++){
        for(let iv=0; iv<vS; iv++){
          const A=iu*(vS+1)+iv, A1=A+1, B=(iu+1)*(vS+1)+iv, B1=B+1;
          idx.push(A,B,A1, B,B1,A1);
        }
      }
      geo.setIndex(idx); geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({
        color:0xbfd7ff, roughness:0.55, metalness:0.0,
        side:THREE.DoubleSide, transparent:true, opacity:0.93
      });
      return new THREE.Mesh(geo, mat);
    }
    group.add(buildSheet(+1));
    group.add(buildSheet(-1));
    return group;
  }
  const hyper2 = buildTwoSheets(X0,Y0,Z0,a,b,c);
  scene.add(hyper2);

  // ---------- Labels ----------
  function makeAxisLabel(tex, pos){
    const el = document.createElement('div'); el.className='axis-label';
    window.katex.render(tex, el, {throwOnError:false});
    const obj = new THREE.CSS2DObject(el); obj.position.copy(pos); return obj;
  }
  function makeLatexLabel(tex, pos){
    const el = document.createElement('div'); el.className='eq-label';
    window.katex.render(tex, el, {throwOnError:false});
    const obj = new THREE.CSS2DObject(el); obj.position.copy(pos); return obj;
  }
  scene.add(makeAxisLabel("\\mathit{x}", new THREE.Vector3(AXLEN+0.3,0,0)));
  scene.add(makeAxisLabel("\\mathit{y}", new THREE.Vector3(0,AXLEN+0.3,0)));
  scene.add(makeAxisLabel("\\mathit{z}", new THREE.Vector3(0,0,AXLEN+0.3)));

  const eqOffset = 0.35;
  const eqObj = makeLatexLabel(
    `\\dfrac{x^{2}}{a^{2}}+\\dfrac{y^{2}}{b^{2}}-\\dfrac{z^{2}}{c^{2}}=-1`,
    new THREE.Vector3(X0, Y0, Z0 + c + eqOffset)
  );
  scene.add(eqObj); eqObj.visible=false;

  // ---------- Overlay groups ----------
  const note = document.getElementById('note');
  function setNote(tex){
    note.innerHTML = "";
    const div = document.createElement('div');
    window.katex.render(tex, div, {throwOnError:false, displayMode:true});
    note.appendChild(div);
  }
  function clearNote(){ note.innerHTML=""; }

  const interceptGroup = new THREE.Group(); scene.add(interceptGroup); interceptGroup.visible=false;
  const traceGroup     = new THREE.Group(); scene.add(traceGroup);     traceGroup.visible=false;
  const sectionGroup   = new THREE.Group(); scene.add(sectionGroup);   sectionGroup.visible=false;
  const symmetryGroup  = new THREE.Group(); scene.add(symmetryGroup);  symmetryGroup.visible=false;

  // ghost plane
  function makePlaneMesh(color, opacity){
    const mat = new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide, transparent:true, opacity, depthWrite:false});
    const geo = new THREE.PlaneGeometry(16,16);
    return new THREE.Mesh(geo, mat);
  }
  const tracePlane = makePlaneMesh(0x8090ff, 0.12);
  scene.add(tracePlane); tracePlane.visible=false;

  // ---------- Camera helpers ----------
  const CAM_WIDE = AXLEN * 2.8;
  const Z_OFF    = AXLEN * 0.4;
  function tweenCamera(toPos, toTarget, ms=800){
    const fromPos=camera.position.clone(), fromTgt=controls.target.clone(), t0=performance.now();
    controls.enabled=false;
    (function step(now){
      const t=Math.min(1,(now-t0)/ms), s=t*t*(3-2*t);
      camera.position.lerpVectors(fromPos,toPos,s);
      controls.target.lerpVectors(fromTgt,toTarget,s);
      controls.update();
      if (t<1) requestAnimationFrame(step);
      else controls.enabled=true;
    })(t0);
  }
  function viewWithDir(dx, dy, ms=600, zMul=1.4){
    const p = new THREE.Vector3(dx, dy, 0).normalize().multiplyScalar(CAM_WIDE);
    p.z = Z_OFF * zMul; tweenCamera(p, new THREE.Vector3(0,0,0), ms);
  }
  function viewOxyAngleWide(){ viewWithDir( 1.0, -0.9, 600, 1.8); }
  function viewOxzAngleWide(){ viewWithDir( 2.0,  0.75); }
  function viewOyzAngleWide(){ viewWithDir( 0.75, 0.75); }
  function viewOverview(){ tweenCamera(new THREE.Vector3(CAM_WIDE, -CAM_WIDE, Z_OFF), new THREE.Vector3(0,0,0), 700); }

  // ---------- Helpers ----------
  function setPlane(mesh, normal, d){
    const up = new THREE.Vector3(0,0,1);
    const n  = normal.clone().normalize();
    mesh.quaternion.setFromUnitVectors(up, n);
    mesh.position.copy(n.multiplyScalar(d));
  }

  function makeEllipseInPlane(center, plane, rx, ry, color=0xFF4040, segments=256){
    const pts=[]; if (rx<=0 || ry<=0) return new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color}));
    for(let i=0;i<=segments;i++){
      const th=2*Math.PI*i/segments; const u = rx*Math.cos(th), v = ry*Math.sin(th);
      if (plane==='z') pts.push(new THREE.Vector3(center.x+u, center.y+v, center.z));
      else if (plane==='y') pts.push(new THREE.Vector3(center.x+u, center.y, center.z+v));
      else if (plane==='x') pts.push(new THREE.Vector3(center.x, center.y+u, center.z+v));
    }
    const g=new THREE.BufferGeometry().setFromPoints(pts);
    return new THREE.Line(g, new THREE.LineBasicMaterial({color}));
  }

  // ----- CLIPPED traces (exactly on the surface mesh range) -----

  // ----- CLIPPED sections on the surface -----
  function makeSectionZ_Ellipse_Clipped(k,a,b,c){
    // ellipse exists iff |k|>=c; also must be <= c cosh U_MAX
    const absK = Math.abs(k);
    if (absK < c || absK > Z_MAX) return new THREE.Group();
    const u = Math.acosh(absK / c);                 // cosh u = |k|/c
    if (u > U_MAX) return new THREE.Group();
    const s = Math.sinh(u);
    const rx = a*s, ry = b*s;                       // exact cross-section radii on surface
    return makeEllipseInPlane(new THREE.Vector3(X0,Y0,k), 'z', rx, ry);
  }

  function makeSectionY_Hyperbola_Clipped(k,a,b,c, steps=300){
    // y = k; require u >= asinh(|k|/b)
    const uMin = Math.asinh(Math.abs(k - Y0)/b);
    if (uMin > U_MAX) return new THREE.Group();
    const group=new THREE.Group(); const mat=new THREE.LineBasicMaterial({color:0xFF4040});
    const addForSheet = (signZ=+1)=>{
  const ptsR=[], ptsL=[];  
      for(let i=0;i<=steps;i++){
        const u = uMin + (U_MAX - uMin)*i/steps;
        const su = Math.sinh(u), cu = Math.cosh(u);
        const under = su*su - ((k - Y0)/b)*((k - Y0)/b);
        if (under < 0) continue;
        const xAbs = a*Math.sqrt(under);
        const z = Z0 + signZ * c*cu;
        const y = k;
        ptsR.push(new THREE.Vector3(X0 + xAbs, y, z));
        ptsL.push(new THREE.Vector3(X0 - xAbs, y, z));
      }
      if (ptsR.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsR), mat));
      if (ptsL.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsL), mat));
    };
    addForSheet(+1); addForSheet(-1);
    return group;
  }

  function makeSectionX_Hyperbola_Clipped(k,a,b,c, steps=300){
    // x = k; require u >= asinh(|k|/a)
    const uMin = Math.asinh(Math.abs(k - X0)/a);
    if (uMin > U_MAX) return new THREE.Group();
    const group=new THREE.Group(); const mat=new THREE.LineBasicMaterial({color:0xFF4040});
    const addForSheet = (signZ=+1)=>{
      const ptsU=[], ptsD=[];
      for(let i=0;i<=steps;i++){
        const u = uMin + (U_MAX - uMin)*i/steps;
        const su = Math.sinh(u), cu = Math.cosh(u);
        const under = su*su - ((k - X0)/a)*((k - X0)/a);
        if (under < 0) continue;
        const yAbs = b*Math.sqrt(under);
        const z = Z0 + signZ * c*cu;
        const x = k;
        ptsU.push(new THREE.Vector3(x, Y0 + yAbs, z));
        ptsD.push(new THREE.Vector3(x, Y0 - yAbs, z));
      }
      if (ptsU.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsU), mat));
      if (ptsD.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsD), mat));
    };
    addForSheet(+1); addForSheet(-1);
    return group;
  }

  // ---------- Buttons ----------
  const btnEq = document.getElementById('btnEquation');
  const btnI = document.getElementById('btnIntercepts');
  const btnT = document.getElementById('btnTraces');
  const btnS = document.getElementById('btnSections');
  const btnC = document.getElementById('btnCentre');
  const btnY = document.getElementById('btnSymmetry');
  const btnResetAll = document.getElementById('btnResetAll');
  const btnPause = document.getElementById('btnPause');

  btnEq.onclick = showEquation;
  btnI.onclick = showIntercepts;
  btnT.onclick = showTraces;
  btnS.onclick = showSections;
  btnC.onclick = showCentre;
  btnY.onclick = showSymmetry;
  btnResetAll.onclick = ()=>{ hideAllOverlays(); isPaused=false; btnPause.textContent='pause'; };

  let isPaused=false;
  btnPause.onclick = ()=>{
    isPaused = !isPaused;
    btnPause.textContent = isPaused ? 'resume' : 'pause';
    if (isPaused){ if (traceTimer){ clearTimeout(traceTimer); traceTimer=null; } }
    else { resumeTraces(); }
  };

  function hideAllOverlays(){
    clearNote();
    if (traceTimer){ clearTimeout(traceTimer); traceTimer=null; }
    if (sectionAnim){ cancelAnimationFrame(sectionAnim); sectionAnim=null; }

    interceptGroup.clear(); interceptGroup.visible=false;
    traceGroup.clear();     traceGroup.visible=false;
    sectionGroup.clear();   sectionGroup.visible=false;
    symmetryGroup.clear();  symmetryGroup.visible=false;

    eqObj.visible = false;
    tracePlane.visible = false;

    gridOxy.visible=true; gridOxz.visible=false; gridOyz.visible=false;

    [btnEq,btnI,btnT,btnS,btnC,btnY].forEach(b=>b && b.classList.remove('active'));
  }

  // ---------- Equation ----------
  function showEquation(){
    hideAllOverlays();
    this.classList.add('active');
    eqObj.visible = true;
    const tex = `\\textbf{Equation:}\\; \\dfrac{x^{2}}{a^{2}}+\\dfrac{y^{2}}{b^{2}}-\\dfrac{z^{2}}{c^{2}}=-1.`;
    setNote(tex);
    viewOverview();
  }

  // ---------- Intercepts ----------
  function showIntercepts(){
    hideAllOverlays();
    this.classList.add('active');
    interceptGroup.visible=true; interceptGroup.clear();

    const pts = [ new THREE.Vector3(X0, Y0, Z0+c), new THREE.Vector3(X0, Y0, Z0-c) ];
    const lab = [ `(\\;0\\;,\\;0\\;,\\;c\\;)`, `(\\;0\\;,\\;0\\;,\\;-c\\;)` ];
    const sph = new THREE.SphereGeometry(0.08, 24, 16);
    const mat = new THREE.MeshBasicMaterial({color:0xff5252});
    pts.forEach((p,i)=>{
      const m=new THREE.Mesh(sph,mat); m.position.copy(p); interceptGroup.add(m);
      interceptGroup.add( makeLatexLabel(lab[i], p.clone().add(new THREE.Vector3(0.14,0.12,0.10))) );
    });
    setNote(`\\textbf{Intercepts:}\\; (0,0,\\pm c).`);
    viewOverview();
  }

  // ---------- Traces (planes through centre, CLIPPED) ----------
  // ----- TRACES (CLIPPED) vẽ theo tham số u, không sinh "cột" song song Oz -----
function makeTraceXZ_Clipped(yConst, a, c, steps=320, color=0xFF4040){
  // y = 0 (xz-plane). Hyperbola trên bề mặt: z = ± c cosh u, x = ± a sinh u, u ∈ (0, U_MAX]
  const group = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({color});
  const eps = 1e-6;

  const buildBranch = (signZ, signX)=>{
    const pts=[];
    for(let i=0;i<=steps;i++){
      const u = (i/steps)*U_MAX;
      const su = Math.sinh(u), cu = Math.cosh(u);
      const x = signX * a * su;
      const z = signZ * c * cu;
      if (Math.abs(x) < eps && i>0) continue; // tránh “dính” vào Oz tạo cột
      pts.push(new THREE.Vector3(X0 + x, yConst, Z0 + z));
    }
    if (pts.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
  };

  // 4 nhánh (±z, ±x), mỗi nhánh là 1 polyline riêng
  buildBranch(+1, +1);
  buildBranch(+1, -1);
  buildBranch(-1, +1);
  buildBranch(-1, -1);

  return group;
}

function makeTraceYZ_Clipped(xConst, b, c, steps=320, color=0xFF4040){
  // x = 0 (yz-plane). z = ± c cosh u, y = ± b sinh u, u ∈ (0, U_MAX]
  const group = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({color});
  const eps = 1e-6;

  const buildBranch = (signZ, signY)=>{
    const pts=[];
    for(let i=0;i<=steps;i++){
      const u = (i/steps)*U_MAX;
      const su = Math.sinh(u), cu = Math.cosh(u);
      const y = signY * b * su;
      const z = signZ * c * cu;
      if (Math.abs(y) < eps && i>0) continue;
      pts.push(new THREE.Vector3(xConst, Y0 + y, Z0 + z));
    }
    if (pts.length>1) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
  };

  buildBranch(+1, +1);
  buildBranch(+1, -1);
  buildBranch(-1, +1);
  buildBranch(-1, -1);

  return group;
}

  let traceStage=0, traceTimer=null;
function showTraces(){
  hideAllOverlays();
  this.classList.add('active');

  traceGroup.visible=true; traceGroup.clear();
  tracePlane.visible = true;

  // y=0 (xz-plane): dùng phiên bản theo u (không tạo 2 cột đỏ dọc Oz)
  setPlane(tracePlane, new THREE.Vector3(0,1,0), Y0);
  traceGroup.add( makeTraceXZ_Clipped(Y0, a, c) );

  setNote("\\textbf{Traces:}\\; y=0\\Rightarrow \\text{hyperbola }\\; \\dfrac{x^{2}}{a^{2}}-\\dfrac{z^{2}}{c^{2}}=-1).");
  viewOxzAngleWide();

  traceStage=1; scheduleNextTraceStage();
}

function scheduleNextTraceStage(){
  if (traceTimer){ clearTimeout(traceTimer); traceTimer=null; }
  if (isPaused) return;
  traceTimer = setTimeout(()=>{
    if (traceStage===1){
      // x=0 (yz-plane): phiên bản theo u
      traceGroup.clear();
      setPlane(tracePlane, new THREE.Vector3(1,0,0), X0);
      traceGroup.add( makeTraceYZ_Clipped(X0, b, c) );
      setNote("\\textbf{Traces:}\\; x=0\\Rightarrow \\text{hyperbola }\\; \\dfrac{y^{2}}{b^{2}}-\\dfrac{z^{2}}{c^{2}}=-1.");
      viewOyzAngleWide();
      traceStage=2; // end
    }
  }, 2700);
}

  function resumeTraces(){
    if (document.getElementById('btnTraces').classList.contains('active') && traceStage<2){
      scheduleNextTraceStage();
    }
  }

  // ---------- Sections (animated, CLIPPED) ----------
  let sectionPhase=0, sectionAnim=null, kVal=0;

  function showSections(){
    hideAllOverlays();
    this.classList.add('active');
    sectionGroup.visible=true; sectionGroup.clear();

    gridOxy.visible=false; gridOxz.visible=false; gridOyz.visible=false;

    const sweepPlane = makePlaneMesh(0x8090ff, 0.12);
    sectionGroup.add(sweepPlane);

    let curveObj = new THREE.Group();
    sectionGroup.add(curveObj);

    // Phase 1: z = k (// Oxy) -> ellipse only when c <= |k| <= c cosh U_MAX
    // Phase 1: z = k (// Oxy) -> ellipse only when c <= |k| <= Z_MAX
sectionPhase=1; 
kVal = Z0 - Z_MAX;          // ⟵ bắt đầu từ đáy sheet dưới
setNote("\\textbf{Sections // Oxy:}\\; z=k\\Rightarrow \\text{ellipse if } |k|\\ge c.");
const qZ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,1));
sweepPlane.quaternion.copy(qZ); 
viewOverview();


    function updateCurve(){
      curveObj.clear();
      if (sectionPhase===1){
        sweepPlane.position.set(0,0,kVal);
        curveObj.add( makeSectionZ_Ellipse_Clipped(kVal, a,b,c) );
      } else if (sectionPhase===2){
        sweepPlane.position.set(0,kVal,0);
        curveObj.add( makeSectionY_Hyperbola_Clipped(kVal, a,b,c) );
      } else if (sectionPhase===3){
        sweepPlane.position.set(kVal,0,0);
        curveObj.add( makeSectionX_Hyperbola_Clipped(kVal, a,b,c) );
      }
    }

    const speed1=0.032, speed2=0.028, speed3=0.028;
    const lim1 = Z0 + Z_MAX;    // ⟵ lên tới đỉnh sheet trên
    const lim2p = Y0 + 1.3*b, lim2m = Y0 - 1.3*b;
    const lim3p = X0 + 1.3*a, lim3m = X0 - 1.3*a;

    const loop = ()=>{
      if (!sectionGroup.visible) return;
      if (!isPaused){
        if (sectionPhase===1){
          kVal += speed1;
          updateCurve();
          if (kVal > lim1){
            sectionPhase=2; kVal = lim2m;
            setNote("\\textbf{Sections // Oxz:}\\; y=k\\Rightarrow \\text{hyperbola}.");
            const qY = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(0,1,0));
            sweepPlane.quaternion.copy(qY); viewOverview(); updateCurve();
          }
        } else if (sectionPhase===2){
          kVal += speed2;
          updateCurve();
          if (kVal > lim2p){
            sectionPhase=3; kVal = lim3m;
            setNote("\\textbf{Sections // Oyz:}\\; x=k\\Rightarrow \\text{hyperbola}.");
            const qX = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(1,0,0));
            sweepPlane.quaternion.copy(qX); viewOverview(); updateCurve();
          }
        } else if (sectionPhase===3){
          kVal += speed3;
          updateCurve();
          if (kVal > lim3p){
            sectionGroup.visible=false; clearNote();
            cancelAnimationFrame(sectionAnim); sectionAnim=null; return;
          }
        }
      }
      sectionAnim = requestAnimationFrame(loop);
    };
    if (sectionAnim) cancelAnimationFrame(sectionAnim);
    sectionAnim = requestAnimationFrame(loop);
  }

  // ---------- Centre ----------
  function showCentre(){
    hideAllOverlays();
    this.classList.add('active');
    const g = new THREE.SphereGeometry(0.12, 24, 16);
    const m = new THREE.MeshBasicMaterial({color:0xff5252});
    const s = new THREE.Mesh(g,m); s.position.set(X0,Y0,Z0);
    const lbl = makeLatexLabel(`(\\;${X0}\\;,\\;${Y0}\\;,\\;${Z0}\\;)`, new THREE.Vector3(X0+0.18,Y0+0.12,Z0+0.12));
    interceptGroup.clear(); interceptGroup.add(s); interceptGroup.add(lbl); interceptGroup.visible=true;
    setNote("\\textbf{Centre:}\\; (0,\\,0,\\,0).");
    viewOverview();
  }

  // ---------- Symmetry ----------
  function showSymmetry(){
    hideAllOverlays();
    this.classList.add('active');
    symmetryGroup.visible=true; symmetryGroup.clear();

    function plane(normal, d, color, opacity){
      const size=16;
      const geo=new THREE.PlaneGeometry(size,size);
      const mat=new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide, transparent:true, opacity});
      const mesh=new THREE.Mesh(geo,mat);
      const up=new THREE.Vector3(0,0,1), n=normal.clone().normalize();
      const q=new THREE.Quaternion().setFromUnitVectors(up,n);
      mesh.quaternion.copy(q);
      mesh.position.copy(n.clone().multiplyScalar(d));
      return mesh;
    }
    symmetryGroup.add( plane(new THREE.Vector3(0,0,1), Z0, 0x4a5160, 0.20) );
    symmetryGroup.add( plane(new THREE.Vector3(0,1,0), Y0, 0x4a5160, 0.20) );
    symmetryGroup.add( plane(new THREE.Vector3(1,0,0), X0, 0x4a5160, 0.20) );

    setNote("\\textbf{Symmetry:}\\; \\text{Symmetric about coordinate planes}");
    viewOverview();
  }

  // ---------- Render loop ----------
  function animate(){
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // ---------- Traces resume helper ----------
  function resumeTraces(){
    if (document.getElementById('btnTraces').classList.contains('active') && traceStage<2){
      scheduleNextTraceStage();
    }
  }
  </script>
</body>
</html>
